#!/bin/bash

PROJECT_NAME="${PROJECT_NAME:-hl-base-project}"  # Si no se pasa, usa el default
echo "üìÅ Usando nombre de proyecto: $PROJECT_NAME"


echo "Verificando si el c√≥digo base ya existe en External..."

#si la carpeta del codigo no esta en external, la copiamos..
if [ ! -d "/home/hl-user/External/${PROJECT_NAME}" ]; then
    echo "üìÇ Copiando ${PROJECT_NAME} a External..."
    cp -r /home/hl-user/hl-src/hl-base-project "/home/hl-user/External/$PROJECT_NAME" # cambiaaaaaaaar
fi

echo "Configurando compilaci√≥n en External..."
#crear el build antes de compilar 
mkdir -p /home/hl-user/External/${PROJECT_NAME}/build
mkdir -p /home/hl-user/External/hl-bin
cd /home/hl-user/External/${PROJECT_NAME}/build

 # Crear configuraci√≥n de VS Code
VSCODE_DIR="/home/hl-user/External/${PROJECT_NAME}/.vscode"
mkdir -p "$VSCODE_DIR"

# Archivo c_cpp_properties.json
cat > "$VSCODE_DIR/c_cpp_properties.json" << EOF
{
    "configurations": [
        {
            "name": "Linux",
            "compileCommands": "\${workspaceFolder}/build/compile_commands.json",
            "compilerPath": "/usr/bin/aarch64-linux-gnu-g++",
            "cStandard": "c17",
            "cppStandard": "gnu++17",
            "intelliSenseMode": "linux-gcc-arm64"
        }
    ],
    "version": 4
}
EOF

# Archivo launch.json
cat > "$VSCODE_DIR/launch.json" << EOF
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Run EmptyApp",
      "type": "cppdbg",
      "request": "launch",
      "program": "\${workspaceFolder}/build/EmptyApp/hlEmptyApp",
      "args": [],
      "stopAtEntry": false,
      "cwd": "\${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "miDebuggerPath": "/usr/bin/aarch64-linux-gnu-gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        }
      ]
    },
    {
      "name": "Debug EmptyApp",
      "type": "cppdbg",
      "request": "launch",
      "program": "\${workspaceFolder}/build/EmptyApp/hlEmptyApp",
      "args": [],
      "stopAtEntry": true,
      "cwd": "\${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "miDebuggerPath": "/usr/bin/aarch64-linux-gnu-gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        },
        {
          "description": "Set disassembly flavor to Intel",
          "text": "-gdb-set disassembly-flavor intel",
          "ignoreFailures": true
        }
      ]
    }
  ]
}
EOF

# Archivo tasks.json
cat > "$VSCODE_DIR/tasks.json" << EOF
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: aarch64-linux-gnu-g++ build active file",
            "command": "/usr/bin/aarch64-linux-gnu-g++",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "\${file}",
                "-o",
                "\${fileDirname}/\${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "\${fileDirname}"
            },
            "problemMatcher": [
                "\$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
EOF



#si no se ha compilado antes, lo compilamos esto hay que quitarlo 

    echo "‚öôÔ∏è  Compilando c√≥digo fuente..."
    cmake .. -D CMAKE_INSTALL_PREFIX=/home/hl-user/External/hl-bin -D HL_BASE_PATH=/home/hl-user/hl-bin > cmake.log 2>&1 # esto elimina el binario de la app el >> cmake.log 2>&1 
    make install >> cmake.log 2>&1 # esto elimina el binario de la app el >> cmake.log 2>&1
    


echo " Inicializaci√≥n completada"




#Ventajas de hacer esto 
    #Verifica si hl-base-project est√° en External/. Si no, lo copia desde /hl-src/hl-base-project.
    #Compila el c√≥digo solo si no ha sido compilado antes, evitando recompilaciones innecesarias.
    #crea un archivo compiled.flag para saber si ya fue compilado antes

#Que hemos conseguido con esto con el compose pues:
    #‚úî Volumen √∫nico (External) para organizar todo sin sobrescribir archivos.
    #Ejecuta initHL.sh en el command para gestionar la inicializaci√≥n y compilaci√≥n.
    #Verifica si el c√≥digo ya est√° copiado antes de duplicarlo.
     #Compila solo si es necesario, optimizando el tiempo de arranque.